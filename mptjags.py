"""
    Copyright 2016
    Nicolas Riesterer <riestern@tf.uni-freiburg.de>
"""

import datetime
import re
import sys

BLACKLIST = ["+", "-", "*", "/"]


def is_number(x):
    """
    Checks, whether a string is numeric or not.

    >>> is_number("ha")
    False
    >>> is_number("123")
    True
    >>> is_number("12.987")
    True
    """

    try:
        int(x)
        return True
    except:
        return False


def get_parameters_from_line(line):
    """
    Extracts all parameters from a given line (i.e. an equation) out of a MPT
    model. Parameters are sequences of non-numeric ASCII sequences.

    Blacklist: "+", "-", "*", "/"
    """

    parameters = []

    norm_line = line.strip()
    for t in re.split("[^\w]+", norm_line):
        if len(t) == 0:
            continue
        if t in BLACKLIST:
            continue
        if is_number(t):
            continue
        parameters.append(t)

    return parameters


def generate_uniform_prior(params, indent=4):
    """
    Generates the JAGS prior declarations for a list of parameters. The
    strings are generated using a specifiable number of indentation
    whitespaces.
    """

    prior_strings = []
    for p in params:
        prior_strings.append(
            "{}{} ~ dunif(0, 1)".format("".join([" "] * indent), p))
    return prior_strings


def generate_category_probs(trees, indent=4):
    """
    Generates the JAGS-equivalent of MPTinR category probabilities, i.e. the
    equations defining the MPT. The strings are generated using a specifiable
    number of indentation whitespaces.
    """

    probs = []
    for t_id, tree in enumerate(trees):
        for f_id, formula in enumerate(tree):
            probs.append("{}pr[{},{}] <- {}".format(
                "".join([" "] * indent), t_id + 1, f_id + 1, formula))

    return probs


def generate_posteriors(trees, indent=4):
    """
    Generates the multinomial distributions for the set of subtrees based on
    the respective category probabilities. The strings are generated using a
    specifiable number of indentation whitespaces.
    """

    posteriors = []
    if len(trees) == 1:
        posteriors.append("{}dat ~ dmulti(pr[1,], trials)".format(
            "".join([" "] * indent)))
    else:
        for t_id, tree in enumerate(trees):
            posteriors.append(
                "{}dat[{},] ~ dmulti(pr[{},], trials[{}])".format(
                    "".join([" "] * indent), t_id + 1, t_id + 1, t_id + 1))

    return posteriors


def parse_mpt_model(filepath):
    """
    Parses the MPT model file line by line, extracting parameters and
    separating different subtrees.
    """

    parameters = []
    tree_formulae = []
    with open(filepath) as model_file:
        current_tree = []

        for l in model_file.readlines():
            norm_line = l.strip()

            if len(norm_line) == 0:
                if len(current_tree) > 0:
                    tree_formulae.append(current_tree)
                    current_tree = []
                continue

            if len(norm_line) != 0 and norm_line[0] == "#":
                continue

            comment_index = norm_line.find("#")
            if (comment_index > 0):
                norm_line = norm_line[0:comment_index]

            for p in get_parameters_from_line(norm_line):
                if p not in parameters:
                    parameters.append(p)

            current_tree.append(norm_line)

        if (len(current_tree) > 0):
            tree_formulae.append(current_tree)

    return tree_formulae, parameters

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python3 mptjags.py <mpt.model>")
        sys.exit(99)

    # Parse the mpt model by extracting tree formulae and parameters
    mpt_model_filepath = sys.argv[1]
    trees, parms = parse_mpt_model(mpt_model_filepath)

    print("# {}".format("".join(["-"] * 98)))
    print("# Model generated by mptjags.py")
    print("#")
    print("# Date: {}".format(datetime.datetime.now()))
    print("# {}".format("".join(["-"] * 98)))
    print()

    print("model {")
    print("\n".join(generate_uniform_prior(parms)))
    print()
    print("\n".join(generate_category_probs(trees)))
    print()
    print("\n".join(generate_posteriors(trees)))
    print("}")
